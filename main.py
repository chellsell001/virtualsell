import os
import uuid
import threading
import re
from datetime import datetime
from dotenv import load_dotenv
import telebot
from telebot import types
from sqlalchemy import create_engine, Column, String, Float, DateTime, Integer
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import requests
from aiosend import MAINNET, TESTNET
from aiosend import CryptoPay









# –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
load_dotenv()
bot = telebot.TeleBot('7643704913:AAG71hJFCxkAZv-WPZjst5n3y61xs_-FlK0')

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
COUNTRIES = {
    'üá∑üá∫ –†–æ—Å—Å–∏—è': {'code': '+7', 'length': 11, 'example': '9123456789'},
    'üá∞üáø –ö–∞–∑–∞—Ö—Å—Ç–∞–Ω': {'code': '+7', 'length': 10, 'example': '7012345678'},
    'üá∫üá¶ –£–∫—Ä–∞–∏–Ω–∞': {'code': '+380', 'length': 9, 'example': '501234567'}
}
SERVICES = ['üì± WhatsApp', '‚úàÔ∏è Telegram']
RESERVE_TIME = 420  # 7 –º–∏–Ω—É—Ç
CRYPTOBOT_TOKEN = '362827:AASWRddZwSqo5PuACaMcJI6oByEGK2fWGhz'
CRYPTOBOT_CURRENCY = 'USDT'
ADMIN_ID = '7783847586'
SELLER_SHARE = 0.85  # 60% –ø—Ä–æ–¥–∞–≤—Ü—É
ADMIN_SHARE = 0.15   # 40% –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É

client = CryptoPay(
    token=CRYPTOBOT_TOKEN,
    network=MAINNET)
Base = declarative_base()

class Number(Base):
    __tablename__ = 'numbers'
    uid = Column(String(36), primary_key=True)
    country = Column(String)
    phone = Column(String)
    service = Column(String)
    seller_id = Column(String)
    price = Column(Float)
    status = Column(String, default='available')
    added_at = Column(DateTime, default=datetime.now)
    reserved_at = Column(DateTime)
    reserved_by = Column(String)
    sms_code = Column(String)
    crypto_invoice_id = Column(String)

class Transaction(Base):
    __tablename__ = 'transactions'
    uid = Column(String(36), primary_key=True)
    number_uid = Column(String(36))
    buyer_id = Column(String)
    seller_id = Column(String)
    amount = Column(Float)
    crypto_amount = Column(Float)
    crypto_currency = Column(String)
    status = Column(String, default='pending')
    created_at = Column(DateTime, default=datetime.now)
    completed_at = Column(DateTime)
    seller_invoice_id = Column(String)
    admin_invoice_id = Column(String)

class PriceLimit(Base):
    __tablename__ = 'price_limits'
    id = Column(Integer, primary_key=True)
    country = Column(String)
    service = Column(String)
    min_price = Column(Float)
    max_price = Column(Float)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
engine = create_engine('sqlite:///number_market_crypto.db', echo=True)
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)
session = Session()

# –°–æ–∑–¥–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ª–∏–º–∏—Ç—ã —Ü–µ–Ω –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
if not session.query(PriceLimit).first():
    for country in COUNTRIES:
        for service in ['WhatsApp', 'Telegram']:
            session.add(PriceLimit(
                country=country,
                service=service,
                min_price=1.0,
                max_price=100.0
            ))
    session.commit()

def generate_uid():
    return str(uuid.uuid4())

def create_keyboard(items, row_width=2):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=row_width)
    buttons = [types.KeyboardButton(item) for item in items]
    markup.add(*buttons)
    return markup

def format_number_info(number):
    return (
        f"üÜî UID: <code>{number.uid}</code>\n"
        f"üåç –°—Ç—Ä–∞–Ω–∞: {number.country}\n"
        f"üîπ –°–µ—Ä–≤–∏—Å: {number.service}\n"
        f"üìû –ù–æ–º–µ—Ä: {number.phone}\n"
        f"üíµ –¶–µ–Ω–∞: {number.price:.2f} USD\n"
    )

        
def validate_phone(country, phone):
    config = COUNTRIES.get(country)
    if not config:
        return False
    cleaned = re.sub(r'\D', '', phone)
    return len(cleaned) == config['length']

def create_crypto_invoice(amount_usd, description, chat_id=None):
    headers = {'Crypto-Pay-API-Token': CRYPTOBOT_TOKEN}
    params = {
        'amount': amount_usd,
        'asset': CRYPTOBOT_CURRENCY,
        'description': description,
        'paid_btn_url': f"https://t.me/{bot.get_me().username}",
        'allow_comments': False
    }
    
    if chat_id:
        params['paid_btn_url'] += f"?start=invoice_{chat_id}"
    
    try:
        response = requests.post(
            'https://pay.crypt.bot/api/createInvoice',
            headers=headers,
            json=params
        )
        data = response.json()
        if data.get('ok'):
            return {
                'invoice_id': data['result']['invoice_id'],
                'pay_url': data['result']['pay_url'],
                'amount': float(data['result']['amount']),
                'currency': data['result']['asset']
            }
        return None
    except Exception as e:
        print("Cryptobot API error:", str(e))
        return None

def check_crypto_payment(invoice_id):
    headers = {'Crypto-Pay-API-Token': CRYPTOBOT_TOKEN}
    params = {'invoice_ids': str(invoice_id)}
    try:
        response = requests.get(
            'https://pay.crypt.bot/api/getInvoices',
            headers=headers,
            params=params
        )
        data = response.json()
        if data.get('ok') and data['result']['items']:
            return data['result']['items'][0]['status'] == 'paid'
    except Exception as e:
        print("Cryptobot API error:", str(e))
    return False

def create_split_invoices(transaction):
    seller_amount = transaction.amount * SELLER_SHARE
    admin_amount = transaction.amount * ADMIN_SHARE
    
    seller_invoice = create_crypto_invoice(
        seller_amount,
        f"–û–ø–ª–∞—Ç–∞ –∑–∞ –Ω–æ–º–µ—Ä {transaction.number_uid} (60%)",
        transaction.seller_id
    )
    
    admin_invoice = create_crypto_invoice(
        admin_amount,
        f"–ö–æ–º–∏—Å—Å–∏—è –∑–∞ –Ω–æ–º–µ—Ä {transaction.number_uid} (40%)",
        ADMIN_ID
    )
    
    if seller_invoice and admin_invoice:
        transaction.seller_invoice_id = seller_invoice['invoice_id']
        transaction.admin_invoice_id = admin_invoice['invoice_id']
        session.commit()
        return True
    return False

def check_price_limits(country, service, price):
    limit = session.query(PriceLimit).filter_by(
        country=country,
        service=service.replace('üì± ', '').replace('‚úàÔ∏è ', '')
    ).first()
    
    if not limit:
        return True
    
    return limit.min_price <= price <= limit.max_price

# –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
@bot.message_handler(commands=['admin'])
def admin_panel(message):
    if str(message.from_user.id) != ADMIN_ID:
        return
    
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    markup.add(
        types.KeyboardButton('üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞'),
        types.KeyboardButton('‚öôÔ∏è –õ–∏–º–∏—Ç—ã —Ü–µ–Ω'),
        types.KeyboardButton('üîô –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é')
    )
    bot.send_message(
        message.chat.id,
        "üë®‚Äçüíª –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:",
        reply_markup=markup
    )

@bot.message_handler(func=lambda m: m.text == 'üîô –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é')
def back_to_main_menu(message):
    start(message)

@bot.message_handler(func=lambda m: m.text == '‚öôÔ∏è –õ–∏–º–∏—Ç—ã —Ü–µ–Ω' and str(m.from_user.id) == ADMIN_ID)
def price_limits_menu(message):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    for country in COUNTRIES:
        markup.add(types.KeyboardButton(f"üõ† {country}"))
    markup.add(types.KeyboardButton('üîô –ù–∞–∑–∞–¥'))
    
    bot.send_message(
        message.chat.id,
        "–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∞–Ω—É –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ª–∏–º–∏—Ç–æ–≤:",
        reply_markup=markup
    )

@bot.message_handler(func=lambda m: m.text.startswith('üõ† ') and str(m.from_user.id) == ADMIN_ID)
def set_price_limits(message):
    country = message.text[2:]
    if country not in COUNTRIES:
        bot.send_message(message.chat.id, "‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç—Ä–∞–Ω–∞")
        return
    
    limits = session.query(PriceLimit).filter_by(country=country).all()
    if not limits:
        bot.send_message(message.chat.id, "‚ùå –õ–∏–º–∏—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
        return
    
    text = f"üìä –õ–∏–º–∏—Ç—ã —Ü–µ–Ω –¥–ª—è {country}:\n\n"
    for limit in limits:
        text += f"{limit.service}: {limit.min_price:.2f}-{limit.max_price:.2f} USD\n"
    
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    for service in ['WhatsApp', 'Telegram']:
        markup.add(types.KeyboardButton(f"‚úèÔ∏è {country} {service}"))
    markup.add(types.KeyboardButton('üîô –ù–∞–∑–∞–¥'))
    
    bot.send_message(
        message.chat.id,
        text,
        reply_markup=markup
    )

@bot.message_handler(func=lambda m: m.text == 'üîô –ù–∞–∑–∞–¥' and str(m.from_user.id) == ADMIN_ID)
def back_in_admin_menu(message):
    admin_panel(message)

@bot.message_handler(func=lambda m: m.text.startswith('‚úèÔ∏è ') and str(m.from_user.id) == ADMIN_ID)
def edit_price_limit(message):
    parts = message.text[2:].split()
    if len(parts) < 2:
        bot.send_message(message.chat.id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç")
        return
    
    country = ' '.join(parts[:-1])
    service = parts[-1]
    
    limit = session.query(PriceLimit).filter_by(
        country=country,
        service=service
    ).first()
    
    if not limit:
        bot.send_message(message.chat.id, "‚ùå –õ–∏–º–∏—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    msg = bot.send_message(
        message.chat.id,
        f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω —Ü–µ–Ω –¥–ª—è {country} ({service}) –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "<–º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞> <–º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞>\n"
        f"–¢–µ–∫—É—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è: {limit.min_price:.2f}-{limit.max_price:.2f} USD",
        reply_markup=types.ReplyKeyboardRemove()
    )


    bot.register_next_step_handler(msg, process_price_limit_update, limit)

def process_price_limit_update(message, limit):
    try:
        min_price, max_price = map(float, message.text.split())
        if min_price < 0 or max_price < min_price:
            raise ValueError
        
        limit.min_price = min_price
        limit.max_price = max_price
        session.commit()
        
        bot.send_message(
            message.chat.id,
            f"‚úÖ –õ–∏–º–∏—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã: {min_price:.2f}-{max_price:.2f} USD"
        )
    except Exception as e:
        bot.send_message(
            message.chat.id,
            f"‚ùå –û—à–∏–±–∫–∞: {str(e)}\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç: 1.0 100.0"
        )

# –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
@bot.message_handler(commands=['start'])
def start(message):
    if str(message.from_user.id) == ADMIN_ID:
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add(
            types.KeyboardButton('üí∞ –ü—Ä–æ–¥–∞—Ç—å –Ω–æ–º–µ—Ä'),
            types.KeyboardButton('üõí –ö—É–ø–∏—Ç—å –Ω–æ–º–µ—Ä'),
            types.KeyboardButton('üìä –ú–æ–∏ –Ω–æ–º–µ—Ä–∞'),
            types.KeyboardButton('üóë –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –º–æ–∏ –ª–æ—Ç—ã'),
            types.KeyboardButton('üë®‚Äçüíª –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å')
        )
    else:
        markup = create_keyboard([
            'üí∞ –ü—Ä–æ–¥–∞—Ç—å –Ω–æ–º–µ—Ä', 
            'üõí –ö—É–ø–∏—Ç—å –Ω–æ–º–µ—Ä', 
            'üìä –ú–æ–∏ –Ω–æ–º–µ—Ä–∞',
            'üóë –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –º–æ–∏ –ª–æ—Ç—ã'
        ])
    
    bot.send_message(
        message.chat.id,
        "üî¢ –ë–∏—Ä–∂–∞ –Ω–æ–º–µ—Ä–æ–≤ –∫—É–ø–ª—è/–ø—Ä–æ–¥–∞–∂–∞(USDT)",
        reply_markup=markup
    )


@bot.message_handler(func=lambda m: m.text == 'üóë –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –º–æ–∏ –ª–æ—Ç—ã')
def delete_all_numbers(message):
    numbers = session.query(Number).filter_by(
        seller_id=str(message.from_user.id),
        status='available'
    ).all()
    
    if not numbers:
        bot.send_message(message.chat.id, "–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return
    
    markup = types.InlineKeyboardMarkup()
    markup.add(
        types.InlineKeyboardButton("‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å –≤—Å–µ", callback_data="confirm_delete_all"),
        types.InlineKeyboardButton("‚ùå –ù–µ—Ç, –æ—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_delete_all")
    )
    
    bot.send_message(
        message.chat.id,
        f"‚ö†Ô∏è –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –í–°–ï —Å–≤–æ–∏ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –Ω–æ–º–µ—Ä–∞ ({len(numbers)} —à—Ç.)?",
        reply_markup=markup
    )

@bot.callback_query_handler(func=lambda call: call.data == 'confirm_delete_all')
def confirm_delete_all(call):
    numbers = session.query(Number).filter_by(
        seller_id=str(call.from_user.id),
        status='available'
    ).all()
    
    count = len(numbers)
    for number in numbers:
        session.delete(number)
    session.commit()
    
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text=f"‚úÖ –£–¥–∞–ª–µ–Ω–æ {count} –Ω–æ–º–µ—Ä–æ–≤."
    )
    bot.answer_callback_query(call.id, f"–£–¥–∞–ª–µ–Ω–æ {count} –Ω–æ–º–µ—Ä–æ–≤")

@bot.callback_query_handler(func=lambda call: call.data == 'cancel_delete_all')
def cancel_delete_all(call):
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text="‚ùå –£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ."
    )
    bot.answer_callback_query(call.id, "–£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ")

@bot.message_handler(func=lambda m: m.text == 'üë®‚Äçüíª –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å' and str(m.from_user.id) == ADMIN_ID)
def admin_panel_button(message):
    admin_panel(message)

@bot.message_handler(func=lambda m: m.text == 'üí∞ –ü—Ä–æ–¥–∞—Ç—å –Ω–æ–º–µ—Ä')
def sell_number_start(message):
    msg = bot.send_message(
        message.chat.id,
        "–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∞–Ω—É –Ω–æ–º–µ—Ä–∞:",
        reply_markup=create_keyboard(COUNTRIES.keys())
    )
    bot.register_next_step_handler(msg, process_sell_country)

def process_sell_country(message):
    if message.text not in COUNTRIES:
        msg = bot.send_message(
            message.chat.id,
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∞–Ω—É –∏–∑ —Å–ø–∏—Å–∫–∞:",
            reply_markup=create_keyboard(COUNTRIES.keys())
        )
        bot.register_next_step_handler(msg, process_sell_country)
        return
    
    user_data = {'country': message.text}
    msg = bot.send_message(
        message.chat.id,
        "–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–∏—Å:",
        reply_markup=create_keyboard(SERVICES)
    )
    bot.register_next_step_handler(msg, process_sell_service, user_data)

def process_sell_service(message, user_data):
    clean_service = message.text.replace('üì± ', '').replace('‚úàÔ∏è ', '')
    if clean_service not in ['WhatsApp', 'Telegram']:
        msg = bot.send_message(
            message.chat.id,
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–∏—Å –∏–∑ —Å–ø–∏—Å–∫–∞:",
            reply_markup=create_keyboard(SERVICES)
        )
        bot.register_next_step_handler(msg, process_sell_service, user_data)
        return
    
    user_data['service'] = clean_service
    example = COUNTRIES[user_data['country']]['example']
    msg = bot.send_message(
        message.chat.id,
        f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (—Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã, —Å –∫–æ–¥–æ–º —Å—Ç—Ä–∞–Ω—ã –ø—Ä–∏–º–µ—Ä: +7{example}):",
        reply_markup=types.ReplyKeyboardRemove()
    )
    bot.register_next_step_handler(msg, process_sell_phone, user_data)

def process_sell_phone(message, user_data):
    if not validate_phone(user_data['country'], message.text):
        country_config = COUNTRIES.get(user_data['country'])
        msg = bot.send_message(
            message.chat.id,
            f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ –¥–ª—è {user_data['country']}.\n"
            f"–¢—Ä–µ–±—É–µ—Ç—Å—è {country_config['length']} —Ü–∏—Ñ—Ä —Å –∫–æ–¥–æ–º —Å—Ç—Ä–∞–Ω—ã (–ø—Ä–∏–º–µ—Ä: +7{country_config['example']}).\n"
            "–í–≤–µ–¥–∏—Ç–µ –µ—â–µ —Ä–∞–∑:"
        )
        bot.register_next_step_handler(msg, process_sell_phone, user_data)
        return
    
    user_data['phone'] = message.text
    msg = bot.send_message(
        message.chat.id,
        f"–í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É –≤ –¥–æ–ª–ª–∞—Ä–∞—Ö USA (–Ω–∞–ø—Ä–∏–º–µ—Ä: 5.50)\n\n–í–ê–ñ–ù–û! –¶–µ–Ω–∞ –æ—Ç: 1.20 USDT."
    )
    bot.register_next_step_handler(msg, process_sell_price, user_data)

def process_sell_price(message, user_data):
    try:
        price = float(message.text)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤ —Ü–µ–Ω—ã
        if not check_price_limits(user_data['country'], user_data['service'], price):
            limit = session.query(PriceLimit).filter_by(
                country=user_data['country'],
                service=user_data['service']
            ).first()
            
            bot.send_message(
                message.chat.id,
                f"‚ùå –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ {limit.min_price:.2f}-{limit.max_price:.2f} USD"
            )
            return
            
        if price <= 0:
            raise ValueError
            
        uid = generate_uid()
        
        new_number = Number(
            uid=uid,
            country=user_data['country'],
            phone=user_data['phone'],
            service=user_data['service'],
            seller_id=str(message.from_user.id),
            price=price
        )
        
        session.add(new_number)
        session.commit()
        
        bot.send_message(
            message.chat.id,
            f"‚úÖ –ù–æ–º–µ—Ä —É—Å–ø–µ—à–Ω–æ –≤—ã—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ –ø—Ä–æ–¥–∞–∂—É!\n\n"
            f"{format_number_info(new_number)}\n"
            "–¢–µ–ø–µ—Ä—å –ø–æ–∫—É–ø–∞—Ç–µ–ª–∏ —Å–º–æ–≥—É—Ç –Ω–∞–π—Ç–∏ –≤–∞—à –Ω–æ–º–µ—Ä –ø–æ UID",
            parse_mode='HTML'
        )
    except ValueError:
        bot.send_message(message.chat.id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ü–µ–Ω—ã. –í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")

@bot.message_handler(func=lambda m: m.text == 'üõí –ö—É–ø–∏—Ç—å –Ω–æ–º–µ—Ä')
def buy_number_start(message):
    msg = bot.send_message(
        message.chat.id,
        "–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∞–Ω—É:",
        reply_markup=create_keyboard(COUNTRIES.keys())
    )
    bot.register_next_step_handler(msg, process_buy_country)

def process_buy_country(message):
    if message.text not in COUNTRIES:
        msg = bot.send_message(
            message.chat.id,
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∞–Ω—É –∏–∑ —Å–ø–∏—Å–∫–∞:",
            reply_markup=create_keyboard(COUNTRIES.keys())
        )
        bot.register_next_step_handler(msg, process_buy_country)
        return
    
    user_data = {'country': message.text}
    msg = bot.send_message(
        message.chat.id,
        "–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–∏—Å:",
        reply_markup=create_keyboard(SERVICES)
    )
    bot.register_next_step_handler(msg, process_buy_service, user_data)

def process_buy_service(message, user_data):
    clean_service = message.text.replace('üì± ', '').replace('‚úàÔ∏è ', '')
    if clean_service not in ['WhatsApp', 'Telegram']:
        msg = bot.send_message(
            message.chat.id,
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–∏—Å –∏–∑ —Å–ø–∏—Å–∫–∞:",
            reply_markup=create_keyboard(SERVICES)
        )
        bot.register_next_step_handler(msg, process_buy_service, user_data)
        return
    
    user_data['service'] = clean_service
    show_available_numbers(message, user_data)

def show_available_numbers(message, user_data, offset=0):
    # –£–±–∏—Ä–∞–µ–º —ç–º–æ–¥–∑–∏ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
    clean_service = user_data['service'].replace('üì± ', '').replace('‚úàÔ∏è ', '')
    
    numbers = session.query(Number).filter_by(
        country=user_data['country'],
        service=clean_service,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º clean_service –±–µ–∑ —ç–º–æ–¥–∑–∏
        status='available'
    ).order_by(Number.added_at.desc()).offset(offset).limit(5).all()
    
    total_numbers = session.query(Number).filter_by(
        country=user_data['country'],
        service=clean_service,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º clean_service –±–µ–∑ —ç–º–æ–¥–∑–∏
        status='available'
    ).count()
    
    if not numbers:
        bot.send_message(
            message.chat.id,
            f"üòï –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤ –¥–ª—è {user_data['service']} ({user_data['country']}).",
            reply_markup=types.ReplyKeyboardRemove()
        )
        return
    
    for num in numbers:
        bot.send_message(
            message.chat.id,
            f"{format_number_info(num)}\n"
            "–î–ª—è –ø–æ–∫—É–ø–∫–∏ –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–æ–º–∞–Ω–¥—É –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ:\n"
            f"<code>/buy_{num.uid}</code>",
            parse_mode='HTML',
            reply_markup=types.ReplyKeyboardRemove()
        )
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    markup = types.InlineKeyboardMarkup()
    
    if offset > 0:
        markup.add(types.InlineKeyboardButton(
            "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", 
            callback_data=f"prev_{user_data['country']}_{user_data['service']}_{offset-5}"
        ))
    
    if offset + 5 < total_numbers:
        markup.add(types.InlineKeyboardButton(
            "–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è", 
            callback_data=f"next_{user_data['country']}_{user_data['service']}_{offset+5}"
        ))
    
    if markup.keyboard:
        bot.send_message(
            message.chat.id,
            f"üìã –°—Ç—Ä–∞–Ω–∏—Ü–∞ {offset//5 + 1} –∏–∑ {(total_numbers-1)//5 + 1}",
            reply_markup=markup
        )

@bot.callback_query_handler(func=lambda call: call.data.startswith(('prev_', 'next_')))
def pagination_handler(call):
    try:
        action, country, service, offset = call.data.split('_')
        offset = int(offset)
        
        user_data = {
            'country': country,
            'service': service
        }
        
        show_available_numbers(call.message, user_data, offset)
        bot.answer_callback_query(call.id)
    except Exception as e:
        bot.answer_callback_query(call.id, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

@bot.callback_query_handler(func=lambda call: call.data.startswith(('prev_', 'next_')))
def pagination_handler(call):
    try:
        action, country, service, offset = call.data.split('_')
        offset = int(offset)
        
        user_data = {
            'country': country,
            'service': service
        }
        
        show_available_numbers(call.message, user_data, offset)
        bot.answer_callback_query(call.id)
    except Exception as e:
        bot.answer_callback_query(call.id, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

# ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)

@bot.message_handler(func=lambda m: m.text.startswith('/buy_'))
def reserve_number(message):
    try:
        uid = message.text.split('_')[1]
        
        number = session.query(Number).filter_by(uid=uid).first()
        
        if not number:
            bot.send_message(message.chat.id, "‚ùå –ù–æ–º–µ—Ä —Å —Ç–∞–∫–∏–º UID –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
            
        if number.status != 'available':
            bot.send_message(message.chat.id, "‚ùå –≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —É–∂–µ –∫—É–ø–ª–µ–Ω –∏–ª–∏ –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω.")
            return
            
        # –°–æ–∑–¥–∞–µ–º –∫—Ä–∏–ø—Ç–æ-–∏–Ω–≤–æ–π—Å
        invoice = create_crypto_invoice(number.price, f"–ü–æ–∫—É–ø–∫–∞ –Ω–æ–º–µ—Ä–∞ {uid}")
        if not invoice:
            bot.send_message(message.chat.id, "‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
            return
        
        number.status = 'reserved'
        number.reserved_at = datetime.now()
        number.reserved_by = str(message.from_user.id)
        number.crypto_invoice_id = invoice['invoice_id']
        session.commit()
        
        # –°–æ–∑–¥–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
        transaction = Transaction(
            uid=generate_uid(),
            number_uid=number.uid,
            buyer_id=str(message.from_user.id),
            seller_id=number.seller_id,
            amount=number.price,
            crypto_amount=invoice['amount'],
            crypto_currency=invoice['currency'],
            status='invoice_created'
        )
        session.add(transaction)
        session.commit()
        
        markup = types.InlineKeyboardMarkup()
        btn_pay = types.InlineKeyboardButton(
            f"üí≥ –û–ø–ª–∞—Ç–∏—Ç—å {invoice['amount']:.2f} {invoice['currency']}", 
            url=invoice['pay_url']
        )
        markup.add(btn_pay)
        
        bot.send_message(
            message.chat.id,
            f"‚è≥ –ù–æ–º–µ—Ä –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ {RESERVE_TIME//60} –º–∏–Ω—É—Ç!\n\n"
            f"{format_number_info(number)}\n"
            f"üíµ –°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ: {invoice['amount']:.2f} {invoice['currency']}\n"
            f"üí∞ –°—É–º–º–∞ –≤ USD: {number.price:.2f}\n\n"
            "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –æ–ø–ª–∞—Ç—ã:",
            reply_markup=markup,
            parse_mode='HTML'
        )
        
        # –ö–Ω–æ–ø–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã
        markup = types.InlineKeyboardMarkup()
        btn_confirm = types.InlineKeyboardButton(
            "‚úÖ –Ø –æ–ø–ª–∞—Ç–∏–ª", 
            callback_data=f"confirm_{transaction.uid}"
        )
        markup.add(btn_confirm)
        
        bot.send_message(
            message.chat.id,
            "–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
            reply_markup=markup
        )
        
        threading.Timer(RESERVE_TIME, check_transaction, args=[uid]).start()
        
    except Exception as e:
        bot.send_message(message.chat.id, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}\n–§–æ—Ä–º–∞—Ç: /buy_UID")

@bot.callback_query_handler(func=lambda call: call.data.startswith('confirm_'))
def confirm_payment(call):
    try:
        transaction_uid = call.data.split('_')[1]
        transaction = session.query(Transaction).filter_by(uid=transaction_uid).first()
        
        if not transaction:
            bot.answer_callback_query(call.id, "‚ùå –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return
            
        number = session.query(Number).filter_by(uid=transaction.number_uid).first()
        if not check_crypto_payment(number.crypto_invoice_id):
            bot.answer_callback_query(call.id, "‚ùå –û–ø–ª–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return
        
        # –°–æ–∑–¥–∞–µ–º —Ä–∞–∑–¥–µ–ª—å–Ω—ã–µ —á–µ–∫–∏
        if not create_split_invoices(transaction):
            bot.answer_callback_query(call.id, "‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —á–µ–∫–æ–≤")
            return
        
        transaction.status = 'paid'
        number.status = 'code_waiting'
        session.commit()
        
        # –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–∫—É–ø–∞—Ç–µ–ª—é
        bot.send_message(
            transaction.buyer_id,
            f"‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!\n\n"
            f"{format_number_info(number)}\n"
            "–û–∂–∏–¥–∞–π—Ç–µ –∫–æ–¥ SMS –æ—Ç –ø—Ä–æ–¥–∞–≤—Ü–∞.",
            parse_mode='HTML'
        )
        

        
        bot.send_message(
            transaction.seller_id,
            f"üî¢ –û–ø–ª–∞—á–µ–Ω –Ω–æ–º–µ—Ä:\n{format_number_info(number)}\n"
            f"üí∏ –ü–æ–ª–Ω–∞—è —Å—É–º–º–∞: {transaction.amount:.2f} USD\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–¥ SMS –ø–æ–∫—É–ø–∞—Ç–µ–ª—é –∫–æ–º–∞–Ω–¥–æ–π (–Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –Ω–µ–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è):\n"
            f"<code>/send_code_{number.uid} –ö–û–î</code>",
            parse_mode='HTML'
        )
        
        # –ß–µ–∫ –¥–ª—è –∞–¥–º–∏–Ω–∞ (40%)


        
        bot.answer_callback_query(call.id, "‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞")
        
    except Exception as e:
        bot.answer_callback_query(call.id, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

@bot.callback_query_handler(func=lambda call: call.data.startswith('withdraw_seller_'))
def withdraw_seller(call):
    try:
        transaction_uid = call.data.split('_')[2]
        transaction = session.query(Transaction).filter_by(uid=transaction_uid).first()
        
        if not transaction:
            bot.answer_callback_query(call.id, "‚ùå –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return
            
        if not transaction.seller_invoice_id:
            bot.answer_callback_query(call.id, "‚ùå –ß–µ–∫ –¥–ª—è –ø—Ä–æ–¥–∞–≤—Ü–∞ –Ω–µ —Å–æ–∑–¥–∞–Ω")
            return
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–ø–ª–∞—Ç—É —á–µ–∫–∞ –ø—Ä–æ–¥–∞–≤—Ü–∞
        if check_crypto_payment(transaction.seller_invoice_id):
            bot.answer_callback_query(call.id, "‚úÖ –°—Ä–µ–¥—Å—Ç–≤–∞ —É–∂–µ –ø–æ–ª—É—á–µ–Ω—ã")
            return
            
        # –°–æ–∑–¥–∞–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ä–µ–¥—Å—Ç–≤
        seller_amount = transaction.amount * SELLER_SHARE
        withdraw_url = f"https://t.me/CryptoBot?start=withdraw_{transaction.seller_invoice_id}"
        
        bot.send_message(
            call.message.chat.id,
            f"üí∏ –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è {seller_amount:.2f} {transaction.crypto_currency}:\n"
            f"1. –û—Ç–∫—Ä–æ–π—Ç–µ @CryptoBot\n"
            f"2. –ù–∞–∂–º–∏—Ç–µ 'Start'\n"
            f"3. –ò–ª–∏ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ –ø—Ä—è–º–æ–π —Å—Å—ã–ª–∫–µ: {withdraw_url}",
            disable_web_page_preview=True
        )
        
        bot.answer_callback_query(call.id, "‚úÖ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ä–µ–¥—Å—Ç–≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞")
        
    except Exception as e:
        bot.answer_callback_query(call.id, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

@bot.callback_query_handler(func=lambda call: call.data.startswith('withdraw_admin_'))
def withdraw_admin(call):
    try:
        transaction_uid = call.data.split('_')[2]
        transaction = session.query(Transaction).filter_by(uid=transaction_uid).first()
        
        if not transaction:
            bot.answer_callback_query(call.id, "‚ùå –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return
            
        if not transaction.admin_invoice_id:
            bot.answer_callback_query(call.id, "‚ùå –ß–µ–∫ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –Ω–µ —Å–æ–∑–¥–∞–Ω")
            return
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–ø–ª–∞—Ç—É —á–µ–∫–∞ –∞–¥–º–∏–Ω–∞
        if check_crypto_payment(transaction.admin_invoice_id):
            bot.answer_callback_query(call.id, "‚úÖ –°—Ä–µ–¥—Å—Ç–≤–∞ —É–∂–µ –ø–æ–ª—É—á–µ–Ω—ã")
            return
            
        # –°–æ–∑–¥–∞–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ä–µ–¥—Å—Ç–≤
        admin_amount = transaction.amount * ADMIN_SHARE
        withdraw_url = f"https://t.me/CryptoBot?start=withdraw_{transaction.admin_invoice_id}"
        
        bot.send_message(
            call.message.chat.id,
            f"üí∏ –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è {admin_amount:.2f} {transaction.crypto_currency}:\n"
            f"1. –û—Ç–∫—Ä–æ–π—Ç–µ @CryptoBot\n"
            f"2. –ù–∞–∂–º–∏—Ç–µ 'Start'\n"
            f"3. –ò–ª–∏ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ –ø—Ä—è–º–æ–π —Å—Å—ã–ª–∫–µ: {withdraw_url}",
            disable_web_page_preview=True
        )
        
        bot.answer_callback_query(call.id, "‚úÖ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ä–µ–¥—Å—Ç–≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞")
        
    except Exception as e:
        bot.answer_callback_query(call.id, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

@bot.callback_query_handler(func=lambda call: call.data.startswith('delete_'))
def delete_number_handler(call):
    try:
        uid = call.data.split('_')[1]
        number = session.query(Number).filter_by(uid=uid).first()
        
        if not number:
            bot.answer_callback_query(call.id, "‚ùå –ù–æ–º–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
            
        if str(number.seller_id) != str(call.from_user.id):
            bot.answer_callback_query(call.id, "‚ùå –≠—Ç–æ –Ω–µ –≤–∞—à –Ω–æ–º–µ—Ä")
            return
            
        if number.status != 'available':
            bot.answer_callback_query(call.id, "‚ùå –ú–æ–∂–Ω–æ —É–¥–∞–ª—è—Ç—å —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –Ω–æ–º–µ—Ä–∞")
            return
            
        session.delete(number)
        session.commit()
        
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=f"‚ùå –ù–æ–º–µ—Ä —É–¥–∞–ª–µ–Ω:\n\n{format_number_info(number)}",
            parse_mode='HTML'
        )
        bot.answer_callback_query(call.id, "‚úÖ –ù–æ–º–µ—Ä —É–¥–∞–ª–µ–Ω")
        
    except Exception as e:
        bot.answer_callback_query(call.id, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

def get_invoice_info(invoice_id):
    """–ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–µ–∫–µ –∏–∑ Cryptobot"""
    headers = {'Crypto-Pay-API-Token': CRYPTOBOT_TOKEN}
    params = {'invoice_ids': str(invoice_id)}
    
    try:
        response = requests.get(
            'https://pay.crypt.bot/api/getInvoices',
            headers=headers,
            params=params
        )
        data = response.json()
        
        if data.get('ok') and data['result']['items']:
            return {
                'pay_url': data['result']['items'][0]['pay_url'],
                'amount': data['result']['items'][0]['amount'],
                'status': data['result']['items'][0]['status']
            }
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —á–µ–∫–µ: {str(e)}")
    
    return None
@bot.message_handler(func=lambda m: m.text.startswith('/send_code_'))
def send_sms_code(message):
    try:
        parts = message.text.split('_')
        uid = parts[2].split()[0]
        sms_code = ' '.join(parts[2].split()[1:])
        
        number = session.query(Number).filter_by(uid=uid).first()
        transaction = session.query(Transaction).filter_by(number_uid=uid, status='paid').first()
        
        if not number or not transaction:
            bot.send_message(message.chat.id, "‚ùå –ù–æ–º–µ—Ä –∏–ª–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
            return
        
        if str(message.from_user.id) != number.seller_id:
            bot.send_message(message.chat.id, "‚ùå –í—ã –Ω–µ –ø—Ä–æ–¥–∞–≤–µ—Ü —ç—Ç–æ–≥–æ –Ω–æ–º–µ—Ä–∞.")
            return
        
        number.sms_code = sms_code
        transaction.status = 'code_sent'
        session.commit()
        
        bot.send_message(
            transaction.buyer_id,
            f"üî¢ –ü—Ä–æ–¥–∞–≤–µ—Ü –æ—Ç–ø—Ä–∞–≤–∏–ª –∫–æ–¥ –¥–ª—è –Ω–æ–º–µ—Ä–∞:\n\n"
            f"{format_number_info(number)}\n"
            f"üî¢ –ö–æ–¥: {sms_code}\n\n"
            "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–¥–∞ –∫–æ–º–∞–Ω–¥–æ–π:\n"
            f"<code>/confirm_code_{number.uid}</code>",
            parse_mode='HTML'
        )
        
        bot.send_message(
            message.chat.id,
            "‚úÖ –ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–∫—É–ø–∞—Ç–µ–ª—é. –û–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è."
        )
    except Exception as e:
        bot.send_message(message.chat.id, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}\n–§–æ—Ä–º–∞—Ç: /send_code_UID –ö–û–î")

@bot.message_handler(func=lambda m: m.text.startswith('/confirm_code_'))
def confirm_code_received(message):
    try:
        uid = message.text.split('_')[2]
        
        number = session.query(Number).filter_by(uid=uid).first()
        transaction = session.query(Transaction).filter_by(number_uid=uid, status='code_sent').first()
        
        if not number or not transaction:
            bot.send_message(message.chat.id, "‚ùå –ù–æ–º–µ—Ä –∏–ª–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
            return
        
        if str(message.from_user.id) != transaction.buyer_id:
            bot.send_message(message.chat.id, "‚ùå –≠—Ç–æ –Ω–µ –≤–∞—à –Ω–æ–º–µ—Ä.")
            return
        seller_amount = transaction.amount * SELLER_SHARE

        # –ü–µ—Ä–µ–≤–æ–¥ –ø—Ä–æ–¥–∞–≤—Ü—É
        client.transfer(
            user_id=transaction.seller_id,
            amount=seller_amount,
            asset=CRYPTOBOT_CURRENCY
        )
        transaction.status = 'completed'
        transaction.completed_at = datetime.now()
        number.status = 'completed'
        session.commit()
        
        bot.send_message(
            message.chat.id,
            f"üéâ –°–¥–µ–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n\n"
            f"{format_number_info(number)}\n"
            f"üî¢ –ö–æ–¥: {number.sms_code}\n\n"
            "–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É!",
            parse_mode='HTML'
        )
        
        bot.send_message(
            transaction.seller_id,
            f"‚úÖ –ü–æ–∫—É–ø–∞—Ç–µ–ª—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–¥–∞:\n\n"
            f"{format_number_info(number)}\n"
            f"üí∞ –°—É–º–º–∞: {transaction.amount:.2f} USD\n"
            f"üî¢ –ö–æ–¥: {number.sms_code}\n\n"
            "–°–¥–µ–ª–∫–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.",
            parse_mode='HTML'
        )
        transaction.status = 'completed'
        session.commit()

        # –†–∞—Å—á—ë—Ç —Å—É–º–º
        


    except Exception as e:
        bot.send_message(message.chat.id, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}\n–§–æ—Ä–º–∞—Ç: /confirm_code_UID")

def check_transaction(uid):
    number = session.query(Number).filter_by(uid=uid).first()
    if number and number.status == 'reserved':
        number.status = 'available'
        number.reserved_at = None
        number.reserved_by = None
        number.crypto_invoice_id = None
        session.commit()
        
        bot.send_message(
            number.reserved_by,
            f"‚åõÔ∏è –í—Ä–µ–º—è —Ä–µ–∑–µ—Ä–≤–∞ –Ω–æ–º–µ—Ä–∞ –∏—Å—Ç–µ–∫–ª–æ:\n\n"
            f"{format_number_info(number)}\n"
            "–ù–æ–º–µ—Ä —Å–Ω–æ–≤–∞ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –ø–æ–∫—É–ø–∫–∏.",
            parse_mode='HTML'
        )

@bot.message_handler(func=lambda m: m.text == 'üìä –ú–æ–∏ –Ω–æ–º–µ—Ä–∞')
def show_user_numbers(message):
    # –ù–æ–º–µ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–æ–¥–∞–µ—Ç
    selling_numbers = session.query(Number).filter_by(
        seller_id=str(message.from_user.id)
    ).order_by(Number.added_at.desc()).all()
    
    if not selling_numbers:
        bot.send_message(message.chat.id, "–£ –≤–∞—Å –Ω–µ—Ç –Ω–æ–º–µ—Ä–æ–≤ –Ω–∞ –ø—Ä–æ–¥–∞–∂–µ.")
        return
    
    bot.send_message(message.chat.id, "üõí –í–∞—à–∏ –Ω–æ–º–µ—Ä–∞ –Ω–∞ –ø—Ä–æ–¥–∞–∂–µ:")
    for num in selling_numbers:
        status = "üü¢ –î–æ—Å—Ç—É–ø–µ–Ω" if num.status == 'available' else \
               "üü° –ó–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω" if num.status == 'reserved' else \
               "üî¥ –ü—Ä–æ–¥–∞–Ω"
        
        markup = types.InlineKeyboardMarkup()
        if num.status == 'available':
            markup.add(types.InlineKeyboardButton(
                "‚ùå –£–¥–∞–ª–∏—Ç—å", 
                callback_data=f"delete_{num.uid}"
            ))
        
        bot.send_message(
            message.chat.id,
            f"{format_number_info(num)}\n"
            f"üìä –°—Ç–∞—Ç—É—Å: {status}\n"
            f"üïí –î–æ–±–∞–≤–ª–µ–Ω: {num.added_at.strftime('%d.%m.%Y %H:%M')}",
            parse_mode='HTML',
            reply_markup=markup
        )

if __name__ == '__main__':
    print("–ë–æ—Ç —Å –ø–æ–ª–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å—é –∑–∞–ø—É—â–µ–Ω!")
    bot.infinity_polling()
